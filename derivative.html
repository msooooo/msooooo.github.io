<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Derivatives Game</title>
<style>
  :root{
    --bg:#071028; --panel:#0b1730; --accent:#2fc3ff; --text:#e8eefc;
    --muted:#8fb0d6; --profit:#39ff88; --loss:#ff6b6b;
    --notify-bg: rgba(47,195,255,0.12);
  }
  html,body{ height:100%; margin:0; }
  body{ font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",Helvetica,Arial; background:var(--bg); color:var(--text); display:flex; height:100vh; box-sizing:border-box; }
  /* LEFT - controls & econ indicators & logs */
  #left{ width:24%; min-width:260px; padding:12px; box-sizing:border-box; background:var(--panel); border-right:1px solid rgba(255,255,255,0.03); overflow:auto;}
  .topRow{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:10px; }
  #datetime{ font-weight:700; font-size:14px; }
  #marketStatus{ font-size:13px; color:#cfeaff; }
  #speedSelect{ background:#06223f; color:var(--text); border-radius:6px; padding:4px; border:1px solid rgba(255,255,255,0.03); }
  .section{ background:#071a30; border-radius:8px; padding:8px; margin-bottom:10px; border:1px solid rgba(255,255,255,0.02); }
  label{ display:block; font-size:12px; color:var(--muted); margin-top:6px; }
  select,input[type="number"],input[type="text"]{ width:100%; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.03); background:#081b36; color:var(--text); box-sizing:border-box; margin-top:4px; }
  button{ width:100%; padding:8px; border-radius:8px; border:none; background:var(--accent); color:#022; font-weight:700; cursor:pointer; margin-top:8px; }
  .muted{ color:var(--muted); font-size:12px; }
  .inline{ display:flex; gap:8px; align-items:center; }
  .small{ font-size:12px; color:var(--muted); }
  /* CENTER - chart + econ/details row */
  #center{ flex:1; display:flex; flex-direction:column; gap:10px; padding:12px; box-sizing:border-box; }
  #chartWrap{ height:34%; background:#081226; border-radius:10px; padding:8px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.03); display:flex; flex-direction:column; }
  #chartCanvas{ width:100%; height:100%; display:block; border-radius:6px; background:#041026; }
  #chartControls{ display:flex; gap:8px; align-items:center; margin-top:8px; }
  .periodBtn{ background:#062b44; color:var(--text); border:1px solid rgba(255,255,255,0.03); padding:6px 10px; border-radius:6px; cursor:pointer; }
  .periodBtn.active{ background:var(--accent); color:#022; }
  #periodReturn{ margin-left:12px; font-weight:700; }
  #below{ display:flex; gap:10px; flex:1; min-height:180px; }
  #econPanel{ flex:2; background:#07162a; border-radius:10px; padding:12px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.03); overflow:auto; position:relative;}
  #econHeader{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
  #econDebugTools1{ display:none; margin-top:8px; gap:8px; }
  #econDebugTools2{ display:none; margin-top:8px; gap:8px; }
  #details{ flex:1; background:#07162a; border-radius:10px; padding:10px; box-sizing:border-box; overflow:auto; border:1px solid rgba(255,255,255,0.03); min-width:260px; }
  /* RIGHT - player info */
  #right{ width:30%; min-width:320px; background:#0b1730; padding:12px; box-sizing:border-box; overflow:auto; border-left:1px solid rgba(255,255,255,0.03); }
  h2{ margin:4px 0 8px 0; color:var(--accent); font-size:16px; }
  .posList{ max-height:280px; overflow:auto; }
  .posItem{ padding:8px; border-radius:6px; background:#061427; margin-bottom:6px; cursor:pointer; border:1px solid rgba(255,255,255,0.02); }
  .posItem:hover{ background:#092135; }
  .profit{ color:var(--profit); font-weight:700; }
  .loss{ color:var(--loss); font-weight:700; }
  .indRow{ display:flex; justify-content:space-between; margin-bottom:6px; align-items:center; }
  .indName{ color:var(--muted); font-size:13px; }
  .indValue{ font-weight:700; }
  /* event log */
  #eventLog{ background:#061424; border-radius:6px; padding:8px; margin-top:8px; height:160px; overflow:auto; border:1px solid rgba(255,255,255,0.02); font-size:13px; }
  .logItem{ margin-bottom:6px; }
  /* notification toast */
  #notif{ position:fixed; right:24px; top:18px; background:var(--notify-bg); color:var(--text); padding:8px 12px; border-radius:6px; border:1px solid rgba(47,195,255,0.15); display:none; z-index:1000; }
  /* debug small controls */
  .debugBtn{ background:#ffd166; color:#022; font-weight:700; border-radius:6px; padding:6px; border:none; cursor:pointer;}
  .tiny{ font-size:12px; padding:6px; }
  /* responsive */
  @media (max-width:1100px){
    #left{ display:none; }
    #right{ width:35%; }
    #center{ padding:8px; }
  }
</style>
</head>
<body>

  <!-- NOTIFICATION -->
  <div id="notif"></div>

  <!-- LEFT: controls + econ snapshot + log -->
  <div id="left">
    <div class="topRow">
      <div>
        <div id="datetime">--</div>
        <div class="small muted">1ì´ˆ = 1ì‹œê°„ Â· í˜„ë¬¼ ì‹œì‘ê°€ 10,000 Â· ver 1.0.19</div>
      </div>
      <div style="text-align:right;">
        <div id="marketStatus" class="small muted">--</div>
        <select id="speedSelect" title="ì‹œë®¬ë ˆì´ì…˜ ë°°ì†" style="margin-top:6px;">
          <option value="1">1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
          <option value="8">8x</option>
          <option value="24">24x</option>
          <option value="48">48x</option>
          <option value="148">148x</option>
          <option value="720">720x</option>
        </select>
      </div>
    </div>

    <div class="section">
      <h3 style="margin:0">í˜„ë¬¼ (Spot)</h3>
      <div class="small muted">í˜„ì¬ê°€</div>
      <div style="font-size:20px; font-weight:700;" id="spotPrice">10000.00</div>
      <div class="inline" style="margin-top:8px;">
        <button id="buySpot">ì‹œì¥ê°€ ë§¤ìˆ˜</button>
        <button id="sellSpot">ì‹œì¥ê°€ ë§¤ë„</button>
      </div>
    </div>

    <div class="section">
      <h3 style="margin:0">ì„ ë¬¼ (Futures)</h3>
      <label>í¬ì§€ì…˜</label>
      <select id="futSide"><option value="Long">Long</option><option value="Short">Short</option></select>
      <label>ë ˆë²„ë¦¬ì§€</label>
      <select id="futLev"><option>1</option><option>2</option><option>5</option><option selected>10</option><option>20</option><option>50</option><option>100</option><option>200</option></select>
      <label>ë§Œê¸°</label>
      <select id="futExp"><option value="1">+1ì›”</option><option value="3">+3ì›”</option><option value="6">+6ì›”</option></select>
      <label>ìˆ˜ëŸ‰</label>
      <input id="futQty" type="number" min="1" value="1" />
      <button id="openFut">í¬ì§€ì…˜ ì—´ê¸°</button>
    </div>

    <div class="section">
      <h3 style="margin:0">ì˜µì…˜ (Option)</h3>
      <label>ì¢…ë¥˜</label>
      <select id="optType"><option value="Call">Call</option><option value="Put">Put</option></select>
      <label>í¬ì§€ì…˜</label>
      <select id="optSide"><option value="Long">ë§¤ìˆ˜</option><option value="Short">ë§¤ë„</option></select>
      <label>í–‰ì‚¬ê°€ (Strike)</label>
      <div style="display:flex; gap:8px; align-items:center;">
        <input id="optK" type="number" value="10000" step="0.01" />
        <div class="small muted" id="optPremiumDisplay">í”„ë¦¬ë¯¸ì—„: 0.00</div>
      </div>
      <label>ë§Œê¸°</label>
      <select id="optExp"><option value="1">+1ì›”</option><option value="3">+3ì›”</option><option value="6">+6ì›”</option></select>
      <label>ìˆ˜ëŸ‰</label>
      <input id="optQty" type="number" min="1" value="1" />
      <button id="tradeOpt">ì˜µì…˜ ê±°ë˜</button>
    </div>

  </div>

  <!-- CENTER -->
  <div id="center">
    <div id="chartWrap">
      <canvas id="chartCanvas"></canvas>
      <div id="chartControls">
        <button class="periodBtn" data-period="1D">1D</button>
        <button class="periodBtn" data-period="1W">1W</button>
        <button class="periodBtn" data-period="1M">1M</button>
        <button class="periodBtn" data-period="3M">3M</button>
        <button class="periodBtn" data-period="6M">6M</button>
        <button class="periodBtn" data-period="1Y">1Y</button>
        <button class="periodBtn" data-period="3Y">3Y</button>
        <button class="periodBtn active" data-period="ALL">ALL</button>
        <div id="periodReturn">ì¦ê°ë¥  +0.00%</div>
      </div>
    </div>

    <div id="below">
      <!-- ECON panel (left half of below) -->
      <div id="econPanel">
        <div id="econHeader">
          <div>
            <h3 style="margin:0">ê²½ì œ ì§€í‘œ (Macro Indicators)</h3>
            <div class="small muted">ì´ ì§€í‘œê°€ Ïƒ(ë³€ë™ì„±)Â·Î¼(ë“œë¦¬í”„íŠ¸)ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤.</div>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <button id="toggleDebug" class="tiny debugBtn">âš™ Debug</button>
          </div>
        </div>

        <!-- debug tools (hidden until toggled) -->
        <div id="econDebugTools" style="margin-top:10px; display:none;">
          <button id="dbgReset" class="debugBtn tiny">ë¦¬ì…‹</button>
          <button id="dbgAddCash" class="debugBtn tiny">í˜„ê¸ˆ+</button>
          <button id="dbgWitch" class="debugBtn tiny">ë³€ë™+</button>
          <button id="dbgWhiteSwan" class="debugBtn tiny">í­ë“±</button>
          <button id="dbgBlackSwan" class="debugBtn tiny">í­ë½</button><br>
          <button id="dbgPolicyRateUP" class="debugBtn tiny">ê¸ˆë¦¬+</button>
          <button id="dbgPolicyRateDOWN" class="debugBtn tiny">ê¸ˆë¦¬-</button>
          <button id="dbgGDPGrowthUP" class="debugBtn tiny">ì„±ì¥+</button>
          <button id="dbgGDPGrowthDOWN" class="debugBtn tiny">ì„±ì¥-</button>
          <button id="dbgShowMU" class="debugBtn tiny">ì¶”ì„¸</button>
        </div>

        <hr style="border:none;height:8px;">

        <!-- indicator rows -->
        <div class="indRow"><div class="indName">VIX (vol index)</div><div class="indValue" id="indVix">20.0</div></div>
        <div class="indRow"><div class="indName">Policy Rate (%)</div><div class="indValue" id="indPolicy">0.50</div></div>
        <div class="indRow"><div class="indName">Bond Yield (%)</div><div class="indValue" id="indBond">1.50</div></div>
        <div class="indRow"><div class="indName">GDP Growth (%)</div><div class="indValue" id="indGdp">2.00</div></div>
        <div class="indRow"><div class="indName">Unemployment (%)</div><div class="indValue" id="indUnemp">5.00</div></div>

        <hr style="border:none;height:8px;">
        <div class="small muted">ì„¤ëª…</div>
        <ul class="small muted">
          <li>VIX: ë§¤ì¼ ì‘ê²Œ ë³€ë™, ê°’ì´ í´ìˆ˜ë¡ Ïƒ ì¦ê°€</li>
          <li>Policy Rate: ì›” ë‹¨ìœ„ í° ìŠ¤í…(ì¤‘ì•™ì€í–‰)</li>
          <li>Bond Yield: ì›” ë‹¨ìœ„ ì‹œì¥ ë³´í–‰</li>
          <li>GDP/Unemp: ëŠë¦¬ê²Œ ë³€í•˜ë©° Î¼ë¥¼ ì¢Œìš°</li>
        </ul>

        <!-- Moved Event Log here so it matches econ panel width -->
        <div style="margin-top:32px;">
          <h4 style="margin:6px 0 4px 0">ì‹œì¥ ì´ë²¤íŠ¸ ë¡œê·¸</h4>
          <div class="small muted">ìµœê·¼ ì´ë²¤íŠ¸ ë° ì£¼ìš” ì•Œë¦¼ (ìµœëŒ€ 100)</div>
          <div id="eventLog" style="margin-top:6px;"></div>
        </div>

      </div>

      <!-- DETAILS panel (right half of below) - ì‘ê²Œ, ìš°ì¸¡ì— ë¶™ìŒ -->
      <div id="details">
        <div class="small muted">ì˜¤ë¥¸ìª½ ë³´ìœ ëª©ë¡ì—ì„œ ì¢…ëª©ì„ í´ë¦­í•˜ë©´, <br> ì´ê³³ì— ì‹¤ì‹œê°„ ì„¸ë¶€ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>
      </div>
    </div>
  </div>

  <!-- RIGHT: player info & positions -->
  <div id="right">
    <h2>í”Œë ˆì´ì–´ ì •ë³´</h2>
    <div class="indRow"><div class="small muted">í˜„ê¸ˆ (Cash)</div><div id="cash" style="font-weight:700">100000.00</div></div>
    <div class="indRow"><div class="small muted">í‰ê°€ê¸ˆì•¡ (Equity)</div><div id="equity" style="font-weight:700">100000.00</div></div>

    <div class="section">
      <h3 style="margin:0">í˜„ë¬¼ ë³´ìœ </h3>
      <div id="spotHoldings" class="posList small">ì—†ìŒ</div>
    </div>

    <div class="section">
      <h3 style="margin:0">ì„ ë¬¼ í¬ì§€ì…˜</h3>
      <div id="futHoldings" class="posList small">ì—†ìŒ</div>
    </div>

    <div class="section">
      <h3 style="margin:0">ì˜µì…˜ í¬ì§€ì…˜</h3>
      <div id="optHoldings" class="posList small">ì—†ìŒ</div>
    </div>
  </div>

<script>
/* ============================
   FULL SIMULATOR JS (UPDATED)
   - Adjusted chart period semantics to use period-start -> now (e.g., today's 00:00 -> now for 1D)
   - Monthly boundary uses first of current month; weekly uses Monday 00:00; yearly uses Jan 1 00:00
   - Time stepping now produces hourly sub-steps when hoursPerTick > 1 so history contains intermediate prices
   - Moved event log into econ panel
   - When a selected detail's underlying position disappears, the details panel resets
   ============================ */

/* ----------------------------
   Base parameters & state (unchanged)
-----------------------------*/
const BASE_VOL = 0.20;    // base mapping when VIX base matches
const VIX_BASE = 20.0;
const RATE_BASE = 2.50
const YIELD_BASE = 3.00
const GDP_BASE = 2.0
const UEMP_BASE = 5.0
const BASE_MU = 0.05;
let R = 0.03, Q = 0.0;

// simulation time
let simDate = new Date("2025-01-01T08:00:00");
let hoursPerTick = 1; // controlled by UI speed

// market state
let state = {
  spot: 10000.0,
  history: [] // [{t:Date, price:number}]
};

// chart period state
let chartPeriod = 'ALL'; // '1D','1W','1M','1Y','ALL'
let hoverIndex = null; // for crosshair

// macro econ indicators
let econ = {
  vix: VIX_BASE,
  policyRate: RATE_BASE,
  bondYield: YIELD_BASE,
  gdpGrowth: GDP_BASE,
  unemployment: UEMP_BASE
};

// player
let player = {
  cash: 100000.0,
  positions: {
    spot: { qty: 0, avg: 0 },
    futures: [], // {side, qty, entry, lev, expiryDate, lockedMargin, notional}
    options: []  // {kind, side, qty, K, entryPremium, openDate, expiryDate}
  },
  log: []
};

// selected detail for live update
let selectedDetail = null;

// event log (for UI)
let eventLog = []; // {t:string, msg:string}

// event flags
let witchingActiveTicks = 0;  // if >0, volatility is multiplied for a few ticks
let blackSwanActiveTicks = 0; // similar

// track last day/month for econ updates (DECLARED to fix ReferenceError)
let lastTickDay = null;
let lastTickMonth = null;

/* ----------------------------
   Utilities (unchanged)
-----------------------------*/
function fmt2(x){ return Number(x).toFixed(2); }
function nowStr(d){
  const Y=d.getFullYear(), M=String(d.getMonth()+1).padStart(2,'0'), D=String(d.getDate()).padStart(2,'0'),
        h=String(d.getHours()).padStart(2,'0'), m=String(d.getMinutes()).padStart(2,'0');
  return `${Y}-${M}-${D} ${h}:${m}`;
}
function addMonthsToFirst(d, months){
  const out = new Date(d.getTime());
  out.setMonth(out.getMonth()+months);
  out.setDate(1);
  out.setHours(0,0,0,0);
  return out;
}
function pushEventLog(msg){
  const t = nowStr(simDate);
  eventLog.unshift({t, msg});
  if (eventLog.length > 200) eventLog.pop();
  renderEventLog();
}
function notify(msg, ms=3000){
  const el = document.getElementById('notif');
  el.innerText = msg; el.style.display = 'block';
  setTimeout(()=>{ el.style.display = 'none'; }, ms);
}

/* ----------------------------
   helper: EMA (for smooth move)
-----------------------------*/
function _ensureEconEma(){
  if (!econ._ema) {
    econ._ema = {
      vix: econ.vix,
      policyRate: econ.policyRate,
      bondYield: econ.bondYield,
      gdpGrowth: econ.gdpGrowth,
      unemployment: econ.unemployment,
      // ê°ì •(ì‹œì¥ì‹¬ë¦¬) ê³µí†µìš”ì¸
      sentiment: 0.0
    };
  }
}

function emaUpdate(key, value, alpha){
  _ensureEconEma();
  const prev = econ._ema[key] !== undefined ? econ._ema[key] : value;
  const next = alpha * value + (1 - alpha) * prev;
  econ._ema[key] = next;
  return next;
}

/* ----------------------------
   Math helpers (unchanged but reorganized for clarity)
-----------------------------*/
function erf(x) {
    const sign = x >= 0 ? 1 : -1;
    x = Math.abs(x);
    const a1 = 0.254829592,
          a2 = -0.284496736,
          a3 = 1.421413741,
          a4 = -1.453152027,
          a5 = 1.061405429,
          p = 0.3275911;
    const t = 1 / (1 + p * x);
    const y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
    return sign * y;
}

function normCdf(x) {
    return 0.5 * (1 + erf(x / Math.sqrt(2)));
}

function black76_call(F, K, r, sigma, tau) {
    if (tau <= 0) return Math.exp(-r * 0) * Math.max(F - K, 0);
    if (sigma <= 0) return Math.exp(-r * tau) * Math.max(F - K, 0);
    const d1 = (Math.log(F / K) + 0.5 * sigma * sigma * tau) / (sigma * Math.sqrt(tau));
    const d2 = d1 - sigma * Math.sqrt(tau);
    return Math.exp(-r * tau) * (F * normCdf(d1) - K * normCdf(d2));
}

function black76_put(F, K, r, sigma, tau) {
    if (tau <= 0) return Math.exp(-r * 0) * Math.max(K - F, 0);
    if (sigma <= 0) return Math.exp(-r * tau) * Math.max(K - F, 0);
    const d1 = (Math.log(F / K) + 0.5 * sigma * sigma * tau) / (sigma * Math.sqrt(tau));
    const d2 = d1 - sigma * Math.sqrt(tau);
    return Math.exp(-r * tau) * (K * normCdf(-d2) - F * normCdf(-d1));
}

function tauYearsFromExpiry(expiryDateStr) {
    const exp = new Date(expiryDateStr + 'T00:00:00');
    const diffMs = Math.max(0, exp.getTime() - simDate.getTime());
    return diffMs / (365 * 24 * 3600 * 1000);
}

/* ----------------------------
   Macro mapping: getCurrentVol (unchanged) and getCurrentMu (REPLACED)
   - getCurrentMu now uses smoothed econ values, a small set of weights, and caps the result.
   - mu is scaled to realistic annual drift magnitudes.
-----------------------------*/
function getCurrentVol() {
    // existing mapping kept: econ.vix scaled to BASE_VOL baseline
    let s = BASE_VOL * (econ.vix / VIX_BASE);
    if (witchingActiveTicks > 0) s *= 2.5;
    if (blackSwanActiveTicks > 0) s *= 3.5;
    // clamp to reasonable bounds (2.0 corresponds to 200% annual sigma high cap)
    return Math.max(0.02, Math.min(2.0, s));
}

function getCurrentMu() {
  // ê¸°ì¤€(ì¤‘ë¦½) ê°’ë“¤ â€” ë‚´ë¶€ì—ì„œ ì •ì˜ (ì™¸ë¶€ ìƒìˆ˜ì™€ ì¶©ëŒí•˜ì§€ ì•ŠìŒ)
  const policyNeutral = RATE_BASE;
  const gdpNeutral = GDP_BASE;
  const unempNeutral = UEMP_BASE;
  const bondNeutral = YIELD_BASE;

  // EMA smoothing (ë‚´ë¶€ ìºì‹œ ì‚¬ìš©) â€” ê°„ë‹¨ êµ¬í˜„
  if (!econ._ema) econ._ema = {};
  function emaUpdateKey(key, value, alpha){
    if (!(key in econ._ema)) { econ._ema[key] = value; return value; }
    econ._ema[key] = econ._ema[key] * (1-alpha) + value * alpha;
    return econ._ema[key];
  }

  const alphaDay = 0.12; // ì´ì „ë³´ë‹¤ ë” ëŠë¦¬ê²Œ(ê³¼ë„í•œ ë°˜ì‘ ë°©ì§€)
  const svix = emaUpdateKey('vix', econ.vix, alphaDay);
  const spolicy = emaUpdateKey('policyRate', econ.policyRate, alphaDay);
  const sbond = emaUpdateKey('bondYield', econ.bondYield, alphaDay);
  const sgdp = emaUpdateKey('gdpGrowth', econ.gdpGrowth, alphaDay);
  const sunemp = emaUpdateKey('unemployment', econ.unemployment, alphaDay);

  // í‘œì¤€í™” (normalize) â€” ê°’ ë²”ìœ„ë¥¼ ì ë‹¹íˆ ë§ì¶°ì„œ ê°€ì¤‘ì¹˜ ì•ˆì •í™”
  const vixNorm = (svix - VIX_BASE) / Math.max(1, VIX_BASE);
  const gdpNorm = (sgdp - gdpNeutral) / Math.max(0.1, Math.abs(gdpNeutral));
  const unempNorm = (sunemp - unempNeutral) / Math.max(0.1, Math.abs(unempNeutral));

  // sentiment: VIX (neg), GDP (pos), Unemp (neg)
  let sentimentRaw = -0.6 * vixNorm + 1.0 * gdpNorm - 0.6 * unempNorm;
  // clamp sentiment to avoid huge swings
  sentimentRaw = Math.max(-2, Math.min(2, sentimentRaw));

  // policy/bond diffs (small)
  const policyDiff = spolicy - policyNeutral;
  const bondDiff = sbond - bondNeutral;

  // weights (ì‘ê²Œ ìœ ì§€)
  const wSent = 0.06;    // sentiment ê¸°ë³¸ ì˜í–¥
  const wPolicy = -0.03; // ì •ì±…ê¸ˆë¦¬ ëŠë¦° ì˜í–¥
  const wBond = -0.01;   // ì±„ê¶Œê¸ˆë¦¬ ì•½í•œ ì˜í–¥
  const wBase = 0.02;    // ì•½ê°„ì˜ ë² ì´ìŠ¤ ë“œë¦¬í”„íŠ¸

  // compose raw mu
  let muRaw = wBase + wSent * sentimentRaw + wPolicy * policyDiff + wBond * bondDiff;

  // ì‘ì€ ëª¨ë©˜í…€(ìµœê·¼ ë¡œê·¸ìˆ˜ìµë¥ )ì„ ì•„ì£¼ ì‘ê²Œ ì¶”ê°€ (mean reversion + ì•ˆì •í™”)
  const historyLen = Math.min(96, state.history.length); // up to last 96 hours
  if (historyLen >= 6) {
    const last = state.history[state.history.length - 1].price;
    const first = state.history[Math.max(0, state.history.length - historyLen)].price;
    const recentRet = Math.log(last / first); // ë¡œê·¸ìˆ˜ìµ
    muRaw += 0.08 * recentRet; // ì•„ì£¼ ì‘ì€ ìŠ¤ì¼€ì¼
  }

  // **ëŒí•‘ & í¬í™”**: muRawë¥¼ tanhë¡œ ì™„ë§Œíˆ í¬í™”ì‹œì¼œ í¬ê²Œ íŠ€ì§€ ì•Šê²Œ í•¨
  const scaled = Math.tanh(muRaw * 1.5) * 0.25; // ìµœì¢… mu âˆˆ (-0.25, 0.25) ì •ë„
  return scaled;
}

function optionPremiumByExpiry(kind, S, K, expiryDateStr) {
  const tau = tauYearsFromExpiry(expiryDateStr);
  const sigma = getCurrentVol();
  const F = S * Math.exp((R - Q) * tau);
  return (kind === 'Call') ? black76_call(F, K, R, sigma, tau) : black76_put(F, K, R, sigma, tau);
}

/* ----------------------------
   Economic updates (REPLACED)
   - daily updates now include a shared 'globalShock' component so VIX/GDP/Unemp/bond move with correlation
   - monthly updates adjust policyRate with lower probability and bond yield moves as function of policy + random
-----------------------------*/
function updateEconForDayChange(){
  // ê³µí†µ ì¶©ê²© + ê°œë³„ ì¶©ê²© ê²°í•© (ê³µí†µì„±ì€ ì‘ê²Œ)
  let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
  const commonZ = Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v) * 0.35; // ê³µí†µìš”ì¸ ê°ì‡„

  function zUnit(){ let a=0,b=0; while(a===0) a=Math.random(); while(b===0) b=Math.random(); return Math.sqrt(-2*Math.log(a))*Math.cos(2*Math.PI*b) * 0.9; }

  // VIX: ê³µí†µì¶©ê²© + idiosyncratic, ê·¸ë¦¬ê³  ê°•í•œ í‰ê· íšŒê·€
  const vixDailyVol = 1.0;
  const vixShock = commonZ * (vixDailyVol * 0.6) + zUnit() * (vixDailyVol * 0.4);
  econ.vix += vixShock;
  // ê°•í•œ í‰ê· íšŒê·€ìœ¼ë¡œ ì¥ê¸°ì¹˜ë¡œ ëŒì•„ì˜¤ê²Œ í•¨
  econ.vix += (VIX_BASE - econ.vix) * 0.05;

  // GDP: ë§¤ìš° ì‘ì€ ì¼ë³„ ë³€í™” + ê°•í•œ ì›”ë³„ ì¡°ì •(ì›”ë‹¨ìœ„ì—ì„œ ì˜ë¯¸ìˆê²Œ ì—…ë°ì´íŠ¸)
  econ.gdpGrowth += 0.002 * zUnit(); // ì•„ì£¼ ì‘ìŒ

  // Unemployment: ì¼ë³„ ë§ˆì´í¬ë¡œ ë…¸ì´ì¦ˆ
  econ.unemployment += 0.003 * zUnit();

  // Bond yield: ì†Œí­ ë…¸ì´ì¦ˆ + ê³µí†µì„± ë°˜ì˜, í‰ê· íšŒê·€
  econ.bondYield += commonZ * 0.01 + zUnit() * 0.005;
  econ.bondYield += (econ.policyRate * 1.05 - econ.bondYield) * 0.02; // ì²œì²œíˆ ì •ì±…ê¸ˆë¦¬ ìˆ˜ì¤€ìœ¼ë¡œ ìˆ˜ë ´

  // ì œí•œ
  econ.vix = Math.max(5, Math.min(120, econ.vix));
  econ.bondYield = Math.max(0, Math.min(20, econ.bondYield));
  econ.gdpGrowth = Math.max(-5, Math.min(9, econ.gdpGrowth));
  econ.unemployment = Math.max(0, Math.min(30, econ.unemployment));
}

function updateEconForMonthChange(){
  // ì•ˆì „ì¥ì¹˜: ì›”ê°„ ë³€í™”ëŠ” ì™„ë§Œí•˜ê²Œ â€” ë³€í™” í™•ë¥  ì¡°ì ˆ
  // policy ë³€ê²½ í™•ë¥ ì€ GDPì™€ ì¸í”Œë ˆ(ì—¬ê¸°ì„  VIX proxy)ë¥¼ í•¨ê»˜ ê³ ë ¤
  const baseRateMoveProb = 0.12; // ê¸°ë³¸ í™•ë¥ 
  // GDP extremeì¼ ë•Œë§Œ í™•ë¥ ì´ ì˜¬ë¼ê°€ê²Œ (ì •ìƒë²”ìœ„ì—ì„  ë‚®ê²Œ ìœ ì§€)
  const gdpFactor = Math.max(0, Math.abs(econ.gdpGrowth - GDP_BASE) / 3.0); // 0..ì•½ê°’
  const prob = Math.min(0.6, baseRateMoveProb + gdpFactor * 0.15);

  if (Math.random() < prob){
    // ì‘ì€ ìŠ¤í…ë“¤ ìœ„ì£¼ë¡œë§Œ
    const stepOptions = [-0.25, -0.125, 0.125, 0.25];
    const step = stepOptions[Math.floor(Math.random()*stepOptions.length)];
    // DAMPENING: ê¸ˆë¦¬ ì§ì ‘ ë§ì…ˆì´ ì•„ë‹ˆë¼ ëª©í‘œê¸ˆë¦¬(target)ë¡œ ì ì§„ ì´ë™
    const target = Math.max(0, econ.policyRate + step);
    econ.policyRate = econ.policyRate * 0.7 + target * 0.3; // ë¶€ë“œëŸ¬ìš´ ì´ë™ (70% inertia)
    pushEventLog(`ğŸ“Š ì •ì±…ê¸ˆë¦¬ ì¡°ì • (soft) -> ${fmt2(econ.policyRate)}%`);
    notify(`ì •ì±…ê¸ˆë¦¬ ${fmt2(econ.policyRate)}%`);
  }

  // Bond yield: trend towards policy*1.05 with damping + small random
  const bondTarget = econ.policyRate * 1.05;
  econ.bondYield += (bondTarget - econ.bondYield) * 0.08 + (Math.random()*0.4 - 0.2);

  // GDP: ì ìš©í•˜ëŠ” ë³€í™”ëŠ” 'ì •ì±…ê¸ˆë¦¬ì˜ ì¥ê¸°ì  ì˜í–¥' - í•˜ì§€ë§Œ ëŒí•‘ì„ ê°•í•˜ê²Œ
  // ì •ì±…ê¸ˆë¦¬ê°€ ì •ìƒì¹˜ë³´ë‹¤ ë†’ìœ¼ë©´ GDPë¥¼ ì†Œí­ ë‚®ì¶”ê³ , ë‚®ìœ¼ë©´ ì†Œí­ ë†’ì¸ë‹¤.
  const policyNeutral = RATE_BASE;
  const policyEffect = (policyNeutral - econ.policyRate) * 0.03; // ì‘ì€ ê³„ìˆ˜
  // add small random monthly term and damping toward long-term trend (2.0)
  const longTermTargetGdp = GDP_BASE;
  econ.gdpGrowth = econ.gdpGrowth * 0.85 + (longTermTargetGdp + policyEffect) * 0.15 + (Math.random()*0.6 - 0.3) * 0.2;

  // Unemployment: negative correlation with GDP, with damping
  const unempTarget = Math.max(0, 6.5 - 0.5 * econ.gdpGrowth); // ê°„ë‹¨í•œ ëª©í‘œì‹
  econ.unemployment += (unempTarget - econ.unemployment) * 0.12 + (Math.random()*0.4 - 0.2) * 0.5;

  // clamp to safe ranges
  econ.policyRate = Math.max(0, Math.min(12, econ.policyRate));
  econ.bondYield = Math.max(0, Math.min(20, econ.bondYield));
  econ.gdpGrowth = Math.max(-5, Math.min(9, econ.gdpGrowth));
  econ.unemployment = Math.max(0, Math.min(30, econ.unemployment));
}
/* ----------------------------
   Events (unchanged)
-----------------------------*/
function isWitchingDay(d) {
    const month = d.getMonth();
    if (![2, 5, 8, 11].includes(month)) return false;
    const first = new Date(d.getFullYear(), month, 1);
    const dayOfWeek = first.getDay();
    let firstFriday = 1 + ((5 - dayOfWeek + 7) % 7);
    firstFriday = firstFriday + 14;
    const dDate = d.getDate();
    return dDate === firstFriday;
}

function triggerWitchingEvent(source = 'system') {
    witchingActiveTicks = Math.max(witchingActiveTicks, 6);
    econ.vix = Math.min(80, econ.vix + (Math.random() * 10));
    pushEventLog(`âš¡ ë³€ë™ì„± ì¦ê°€ (${source}) â€” íŒŒìƒìƒí’ˆ ë§Œê¸°ë¡œ ë³€ë™ì„± ì¼ì‹œ ì¦ê°€`);
    notify('âš¡ ë³€ë™ì„± ì¼ì‹œ ì¦ê°€', 4000);
}

function triggerWhiteSwan(source = 'system') {
    blackSwanActiveTicks = Math.max(blackSwanActiveTicks, 12);
    econ.vix = Math.min(80, econ.vix + (Math.random() * 50));
    const shockPct = +(10 + Math.random() * 10);
    const factor = 1 + shockPct / 100;
    state.spot *= factor;
    if (state.spot < 0.01) state.spot = 0.01;
    pushEventLog(`ğŸŒŸ ëŒ€í­ë“±(${source}) ë°œìƒ â€” ê°€ê²© ${fmt2(shockPct)}% ê¸‰ë“±, VIX ê¸‰ë“±`);
    notify('ğŸŒŸ ëŒ€í­ë“± ë°œìƒ!', 6000);
}

function triggerBlackSwan(source = 'system') {
    blackSwanActiveTicks = Math.max(blackSwanActiveTicks, 12);
    econ.vix = Math.min(80, econ.vix + (Math.random() * 50));
    const shockPct = -(10 + Math.random() * 10);
    const factor = 1 + shockPct / 100;
    state.spot *= factor;
    if (state.spot < 0.01) state.spot = 0.01;
    pushEventLog(`ğŸ’£ ëŒ€í­ë½(${source}) ë°œìƒ â€” ê°€ê²© ${fmt2(shockPct)}% ê¸‰ë½, VIX ê¸‰ë“±`);
    notify('ğŸ’£ ëŒ€í­ë½ ë°œìƒ!', 6000);
}

function triggerPolicyRateUP(source = 'system') {
    const step = 0.25
    econ.policyRate = Math.max(0, econ.policyRate + step);
    pushEventLog(`ğŸ“Š ì •ì±…ê¸ˆë¦¬ ${step>0? 'ì¸ìƒ':'ì¸í•˜'} ${fmt2(step)}p% -> ${fmt2(econ.policyRate)}%`);
    notify(`ì •ì±…ê¸ˆë¦¬ ${fmt2(econ.policyRate)}%`);
}

function triggerPolicyRateDOWN(source = 'system') {
    const step = -0.25
    econ.policyRate = Math.max(0, econ.policyRate + step);
    pushEventLog(`ğŸ“Š ì •ì±…ê¸ˆë¦¬ ${step>0? 'ì¸ìƒ':'ì¸í•˜'} ${fmt2(step)}p% -> ${fmt2(econ.policyRate)}%`);
    notify(`ì •ì±…ê¸ˆë¦¬ ${fmt2(econ.policyRate)}%`);
}

function triggerGDPGrowthUP(source = 'system') {
    const step = 0.25
    econ.gdpGrowth = Math.max(0, econ.gdpGrowth + step);
    pushEventLog(`ğŸ“Š GDP ${step>0? 'ì„±ì¥':'ì—­ì„±ì¥'} ${fmt2(step)}p% -> ${fmt2(econ.gdpGrowth)}%`);
}

function triggerGDPGrowthDOWN(source = 'system') {
    const step = -0.25
    econ.gdpGrowth = Math.max(0, econ.gdpGrowth + step);
    pushEventLog(`ğŸ“Š GDP ${step>0? 'ì„±ì¥':'ì—­ì„±ì¥'} ${fmt2(step)}p% -> ${fmt2(econ.gdpGrowth)}%`);
}

/* ----------------------------
   Time stepping (now hourly sub-steps when hoursPerTick>1)
-----------------------------*/
function isSpotOpenAt(d){ const h=d.getHours(); return (h>=0 && h<=12); }

function stepMarket(){
  // We'll perform 'hoursPerTick' steps of 1 hour each so intermediate prices exist
  for (let step=0; step<Math.max(1,hoursPerTick); step++){
    // advance by 1 hour
    const prevDate = new Date(simDate);
    simDate = new Date(simDate.getTime() + 1*3600*1000);

    // detect day/month transitions
    const curDay = simDate.getDate();
    const curMonth = simDate.getMonth() + 1;
    if (lastTickDay === null || curDay !== lastTickDay){
      updateEconForDayChange();
      if (Math.random() < 0.0005){ triggerBlackSwan('random'); }
      if (Math.random() < 0.0005){ triggerWhiteSwan('random'); }
    }
    if (lastTickMonth === null || curMonth !== lastTickMonth){
      updateEconForMonthChange();
    }
    lastTickDay = curDay; lastTickMonth = curMonth;

    // compute dt for 1 hour
    const dt = 1 / (24*365);
    const sigma = getCurrentVol();
    const mu = getCurrentMu();
    // gaussian
    let u=0,v=0; while(u===0) u=Math.random(); while(v===0) v=Math.random();
    const z = Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    const factor = Math.exp((mu - 0.5*sigma*sigma)*dt + sigma*Math.sqrt(dt)*z);
    state.spot *= factor; if (state.spot < 0.01) state.spot = 0.01;
    // record this hourly price
    state.history.push({ t: new Date(simDate), price: state.spot });

    // scheduled witching check at 08:00
    if (isWitchingDay(simDate) && simDate.getHours() === 8 && Math.random() < 0.9){ triggerWitchingEvent('scheduled'); }

    // expiries: only check after hourly advancement to catch expiries that happen at 00:00
    checkExpiries();

    // decrement temporary event counters
    if (witchingActiveTicks > 0) witchingActiveTicks--;
    if (blackSwanActiveTicks > 0) blackSwanActiveTicks--;
  }
  // after all sub-steps, render UI
  renderAll();
}

/* ----------------------------
   Trading & expiry logic unchanged but ensure details are cleared when positions removed
-----------------------------*/
function buySpot() {
    if (!isSpotOpenAt(simDate)) return notify('í˜„ë¬¼ì€ ì¥ì´ ì—´ë¦° ì‹œê°„ì¸ 00:00~12:00ë§Œ ê±°ë˜ ê°€ëŠ¥í•©ë‹ˆë‹¤',2000);
    const cost = state.spot;
    if (player.cash < cost) return notify('í˜„ê¸ˆ ë¶€ì¡±',2000);
    player.cash -= cost;
    const s = player.positions.spot;
    const prevTotal = s.qty * s.avg;
    s.qty += 1;
    s.avg = (prevTotal + cost) / s.qty;
    pushEventLog(`ğŸŸ¢ í˜„ë¬¼ :: ë§¤ìˆ˜ | ìˆ˜ëŸ‰ 1 | ë§¤ìˆ˜ê¸ˆì•¡ ${fmt2(cost)}`,2000);
    renderAll();
}

function sellSpot() {
    if (!isSpotOpenAt(simDate)) return notify('í˜„ë¬¼ì€ ì¥ì´ ì—´ë¦° ì‹œê°„ì¸ 00:00~12:00ë§Œ ê±°ë˜ ê°€ëŠ¥í•©ë‹ˆë‹¤',2000);
    const s = player.positions.spot;
    if (s.qty <= 0) return notify('ë³´ìœ  í˜„ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤',2000);
    player.cash += state.spot;
    s.qty -= 1;
    if (s.qty === 0) s.avg = 0;
    pushEventLog(`ğŸ”´ í˜„ë¬¼ :: ë§¤ë„ | ìˆ˜ëŸ‰ 1 | ë§¤ë„ê¸ˆì•¡ ${fmt2(state.spot)}`,2000);
    renderAll();
}

function openFuture() {
    const side = document.getElementById('futSide').value;
    const lev = Number(document.getElementById('futLev').value) || 1;
    const months = Number(document.getElementById('futExp').value) || 1;
    const qty = Math.max(1, Number(document.getElementById('futQty').value) || 1);
    const expiryDate = addMonthsToFirst(simDate, months).toISOString().slice(0, 10);
    const tau = tauYearsFromExpiry(expiryDate);
    const entry = state.spot * Math.exp((R - Q) * tau);
    const notional = entry * qty;
    const margin = notional / lev;
    if (player.cash < margin) return notify(`ì¦ê±°ê¸ˆ ë¶€ì¡±: ${fmt2(margin)}`,2000);
    player.cash -= margin;
    player.positions.futures.push({
        side,
        qty,
        entry,
        lev,
        expiryDate,
        lockedMargin: margin,
        notional
    });
    if (side === 'Long') {
      pushEventLog(`ğŸŸ¡ ì„ ë¬¼ :: í¬ì§€ì…˜ ${side} | ìˆ˜ëŸ‰ ${qty} | ì§„ì…ê°€ ${fmt2(entry)} | ë ˆë²„ë¦¬ì§€ ë¹„ìœ¨ x${lev}`);
    } else {
      pushEventLog(`ğŸŸ¡ ì„ ë¬¼ :: í¬ì§€ì…˜ ${side} | ìˆ˜ëŸ‰ ${qty} | ì§„ì…ê°€ ${fmt2(entry)} | ë ˆë²„ë¦¬ì§€ ë¹„ìœ¨ x${lev}`);
    }
    
    
    renderAll();
}

function tradeOption() {
    const kind = document.getElementById('optType').value;
    const side = document.getElementById('optSide').value;
    const K = Number(document.getElementById('optK').value) || state.spot;
    const months = Number(document.getElementById('optExp').value) || 1;
    const qty = Math.max(1, Number(document.getElementById('optQty').value) || 1);
    const expiryDate = addMonthsToFirst(simDate, months).toISOString().slice(0, 10);
    const prem = optionPremiumByExpiry(kind, state.spot, K, expiryDate);
    if (side === 'Long') {
        const total = prem * qty;
        if (player.cash < total) return notify('í”„ë¦¬ë¯¸ì—„ ì§€ë¶ˆê¸ˆ ë¶€ì¡±',2000);
        player.cash -= total;
        player.positions.options.push({
            kind,
            side,
            qty,
            K,
            entryPremium: prem,
            openDate: new Date(simDate),
            expiryDate
        });
        pushEventLog(`ğŸŸ¢ ì˜µì…˜ :: í¬ì§€ì…˜ ${side} ${kind} | ìˆ˜ëŸ‰ ${qty} | í–‰ì‚¬ê°€ ${fmt2(K)} | í”„ë¦¬ë¯¸ì—„ ${fmt2(prem)}`);
    } else {
        player.cash += prem * qty;
        player.positions.options.push({
            kind,
            side,
            qty,
            K,
            entryPremium: prem,
            openDate: new Date(simDate),
            expiryDate
        });
        pushEventLog(`ğŸ”´ ì˜µì…˜ :: í¬ì§€ì…˜ ${side} ${kind} | ìˆ˜ëŸ‰ ${qty} | í–‰ì‚¬ê°€ ${fmt2(K)} | í”„ë¦¬ë¯¸ì—„ ${fmt2(prem)}`);
    }
    renderAll();
}

function checkExpiries() {
    const today = new Date(simDate.getFullYear(), simDate.getMonth(), simDate.getDate());
    for (let i = player.positions.futures.length - 1; i >= 0; i--) {
        const f = player.positions.futures[i];
        const exp = new Date(f.expiryDate + 'T00:00:00');
        if (today >= exp) {
            if (f.side === 'Long') {
                const pay = f.entry * f.qty;
                player.cash -= pay;
                const s = player.positions.spot;
                const prevTotal = s.qty * s.avg;
                s.qty += f.qty;
                s.avg = (s.qty > 0) ? ((prevTotal + f.qty * f.entry) / s.qty) : 0;
                player.cash += f.lockedMargin;
                pushEventLog(`ğŸ“¦ ì„ ë¬¼ Long ë§Œê¸° :: ì§€ë¶ˆê¸ˆ ${fmt2(pay)} | í˜„ë¬¼ ì¸ìˆ˜ëŸ‰ ${f.qty}`);
            } else {
                const receive = f.entry * f.qty;
                const s = player.positions.spot;
                if (s.qty >= f.qty) {
                    s.qty -= f.qty;
                    if (s.qty === 0) s.avg = 0;
                    player.cash += receive;
                    player.cash += f.lockedMargin;
                    pushEventLog(`ğŸ“¦ ì„ ë¬¼ Short ë§Œê¸° :: í˜„ë¬¼ ì¸ë„ëŸ‰ ${f.qty} | í˜„ë¬¼ ì”ì—¬ëŸ‰ ${s.qty} | ì •ì‚°ê¸ˆ ${fmt2(receive)}`);
                } else {
                    const buyCost = state.spot * f.qty;
                    player.cash += receive;
                    player.cash -= buyCost;
                    player.cash += f.lockedMargin;
                    pushEventLog(`ğŸ“¦ ì„ ë¬¼ Short ë§Œê¸° :: í˜„ë¬¼ ì¸ë„ëŸ‰ ${f.qty} | í˜„ë¬¼ ë§¤ìˆ˜ê¸ˆ ${fmt2(buyCost)} | ì •ì‚°ê¸ˆ ${fmt2(receive - buyCost)}`);
                }
            }
            witchingActiveTicks = Math.max(witchingActiveTicks, 4);
            player.positions.futures.splice(i, 1); // clear selection if it pointed here
            if (selectedDetail && selectedDetail.type === 'Future') selectedDetail = null;
        }
    }
    for (let i = player.positions.options.length - 1; i >= 0; i--) {
        const o = player.positions.options[i];
        const exp = new Date(o.expiryDate + 'T00:00:00');
        if (today >= exp) {
            const S = state.spot;
            let payoffPer = 0;
            if (o.kind === 'Call') payoffPer = Math.max(S - o.K, 0);
            else payoffPer = Math.max(o.K - S, 0);
            const total = payoffPer * o.qty;
            if (o.side === 'Long') {
                player.cash += total;
                pushEventLog(`ğŸ’° ì˜µì…˜ Long ë§Œê¸° :: ìˆ˜ìµê¸ˆ ${fmt2(total)}`);
            } else {
                player.cash -= total;
                pushEventLog(`ğŸ’¸ ì˜µì…˜ Short ë§Œê¸° ::  ì§€ê¸‰ê¸ˆ ${fmt2(total)}`);
            }
            witchingActiveTicks = Math.max(witchingActiveTicks, 3);
            player.positions.options.splice(i, 1);
            if (selectedDetail && selectedDetail.type === 'Option') selectedDetail = null;
        }
    }
    // ensure details panel reset if selectedDetail now invalid
    updateDetails();
}

function closeFuture(idx) {
    const f = player.positions.futures[idx];
    const tau = tauYearsFromExpiry(f.expiryDate);
    const curF = state.spot * Math.exp((R - Q) * tau);
    const pnlPer = (curF - f.entry) * (f.side === 'Long' ? 1 : -1);
    const pnl = pnlPer * f.qty;
    const pct = f.notional ? (pnl / f.notional) * f.lev * 100 : 0;
    player.cash += f.lockedMargin + pnl;
    player.positions.futures.splice(idx, 1);
    pushEventLog(`âœ‚ï¸ ì„ ë¬¼ ì²­ì‚° :: í¬ì§€ì…˜ ${f.side} | ìˆ˜ìµê¸ˆ ${fmt2(pnl)} (${fmt2(pct)}%) | ì •ì‚°ê¸ˆ ${fmt2(f.lockedMargin)}`);
    if (selectedDetail && selectedDetail.type === 'Future') selectedDetail = null;
    renderAll();
}

function closeOption(idx) {
    const o = player.positions.options[idx];
    const cur = optionPremiumByExpiry(o.kind, state.spot, o.K, o.expiryDate);
    let pnl = 0;
    if (o.side === 'Long') {
      pnl = (cur - o.entryPremium) * o.qty;
      player.cash += pnl + o.entryPremium * o.qty;
    } else {
      pnl = (o.entryPremium - cur) * o.qty;
      player.cash += pnl - o.entryPremium * o.qty;
    }
    const totalPaid = o.entryPremium * o.qty;
    const pct = totalPaid ? (pnl / totalPaid) * 100 : 0;
    player.positions.options.splice(idx, 1);
    pushEventLog(`âœ‚ï¸ ì˜µì…˜ ì²­ì‚° :: í¬ì§€ì…˜  ${o.side} ${o.kind} | ìˆ˜ìµê¸ˆ ${fmt2(pnl)} (${fmt2(pct)}%)`);
    if (selectedDetail && selectedDetail.type === 'Option') selectedDetail = null;
    renderAll();
}

/* ----------------------------
   Equity & UI helpers (unchanged)
-----------------------------*/
function computeEquity() {
    const s = player.positions.spot;
    const spotVal = s.qty * state.spot;
    let futUnreal = 0;
    let futPaid = 0;
    player.positions.futures.forEach(f => {
        const tau = tauYearsFromExpiry(f.expiryDate);
        const futPaid = f.notional;
        const curF = state.spot * Math.exp((R - Q) * tau);
        const pnlPer = (curF - f.entry) * (f.side === 'Long' ? 1 : -1);
        futUnreal += pnlPer * f.qty;
        futPaid += f.notional;
    });
    let optUnreal = 0;
    let optPaid = 0;
    player.positions.options.forEach(o => {
        const cur = optionPremiumByExpiry(o.kind, state.spot, o.K, o.expiryDate);
        if (o.side === 'Long') {
          optUnreal += (cur - o.entryPremium) * o.qty;
          optPaid += o.entryPremium * o.qty;
        }
        else { 
          optUnreal += (o.entryPremium - cur) * o.qty; 
          optPaid -= o.entryPremium * o.qty;
        }
    });
    const total = player.cash + spotVal + futUnreal + futPaid + optUnreal + optPaid;
    return {
        total,
        spotVal,
        futUnreal,
        futPaid,
        optUnreal,
        optPaid
    };
}

/* ----------------------------
   Chart drawing (update: period semantics start->now)
-----------------------------*/
const canvas2 = document.getElementById('chartCanvas');
const ctx2 = canvas2.getContext('2d');

function periodStartDate(){
  const end = new Date(simDate);

  switch(chartPeriod){
    case '1D': {
      const d = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 0, 0, 0);
      return d;
    }

    case '1W': {
      const d = new Date(end.getTime() - 7 * 24 * 3600 * 1000);
      return d;
    }

    case '1M': {
      const d = new Date(end);
      d.setMonth(d.getMonth() - 1);
      return d;
    }

    case '3M': {
      const d = new Date(end);
      d.setMonth(d.getMonth() - 3);
      return d;
    }

    case '6M': {
      const d = new Date(end);
      d.setMonth(d.getMonth() - 6);
      return d;
    }

    case '1Y': {
      const d = new Date(end);
      d.setFullYear(d.getFullYear() - 1);
      return d;
    }
      
    case '3Y': {
      const d = new Date(end);
      d.setFullYear(d.getFullYear() - 3);
      return d;
    }

    default:
      // ALL
      return new Date(0);
  }
}

function getPeriodFilteredData(){
  if (!state.history || state.history.length===0) return [];
  if (chartPeriod === 'ALL') return state.history.slice();
  const start = periodStartDate();
  return state.history.filter(h => h.t.getTime() >= start.getTime());
}

function calcPeriodReturn(data){ if (!data || data.length<2) return null; const first = data[0].price; const last = data[data.length-1].price; const pct = (last - first) / first * 100; return pct; }

let isHovering = false; let hoverPos = null;

function drawChart() {
    const canvas = canvas2;
    const ctx = ctx2;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#041426";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const dataFull = getPeriodFilteredData();
    if (!dataFull || dataFull.length < 2) {
        ctx.fillStyle = "#cfeaff";
        ctx.font = "12px system-ui";
        ctx.fillText("ê°€ê²© ì°¨íŠ¸ ì¤€ë¹„ ì¤‘...", 8, 16);
        document.getElementById('periodReturn').innerText = `ì¦ê°ë¥  +0.00%`;
        return;
    }

    const data = dataFull.map(d => d.price);
    const max = Math.max(...data),
        min = Math.min(...data);
    const range = (max - min) || 1;

    ctx.beginPath();
    ctx.lineWidth = 2;
    if (blackSwanActiveTicks > 0) ctx.strokeStyle = "#ff6b6b";
    else if (witchingActiveTicks > 0) ctx.strokeStyle = "#ffd166";
    else ctx.strokeStyle = "#2fc3ff";
    for (let i = 0; i < data.length; i++) {
        const x = (i / (data.length - 1)) * canvas.width;
        const y = canvas.height - ((data[i] - min) / range) * canvas.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = "#cfeaff";
    ctx.font = "12px system-ui";
    const latest = data[data.length - 1];
    ctx.fillText(`í˜„ì¬ê°€: ${fmt2(latest)}`, 8, 16);
    ctx.fillText(`VIX: ${fmt2(econ.vix)} Ïƒ:${fmt2(getCurrentVol())}`, 120, 16);

    const ret = calcPeriodReturn(dataFull);
    if (ret !== null) {
        const el = document.getElementById('periodReturn');
        el.innerText = `ì¦ê°ë¥  ${ret>=0?'+':''}${fmt2(ret)}%`;
        el.style.color = ret >= 0 ? 'var(--profit)' : 'var(--loss)';
    }

    // hover crosshair
    if (isHovering && hoverPos && data.length > 0) {
        const i = hoverPos.index;
        const px = hoverPos.x;
        const py = hoverPos.y;
        ctx.strokeStyle = 'rgba(200,230,255,0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(px, 0);
        ctx.lineTo(px, canvas.height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, py);
        ctx.lineTo(canvas.width, py);
        ctx.stroke();
        const h = dataFull[i];
        if (h) {
            const boxW = 180,
                boxH = 48;
            const bx = Math.min(canvas.width - boxW - 10, px + 8);
            const by = Math.max(8, Math.min(canvas.height - boxH - 8, py - boxH / 2));
            ctx.fillStyle = 'rgba(6,18,36,0.95)';
            ctx.fillRect(bx, by, boxW, boxH);
            ctx.strokeStyle = 'rgba(47,195,255,0.15)';
            ctx.strokeRect(bx, by, boxW, boxH);
            ctx.fillStyle = '#cfeaff';
            ctx.font = '12px system-ui';
            ctx.fillText(`${h.t.getFullYear()}-${String(h.t.getMonth()+1).padStart(2,'0')}-${String(h.t.getDate()).padStart(2,'0')} ${String(h.t.getHours()).padStart(2,'0')}:${String(h.t.getMinutes()).padStart(2,'0')}`, bx + 8, by + 18);
            ctx.fillText(`Price: ${fmt2(h.price)}`, bx + 8, by + 36);
        }
    }
}

// canvas hover handlers - similar but using period-aware mapping
canvas2.addEventListener('mousemove', (ev) => {
  const rect = canvas2.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;

  const dataFull = getPeriodFilteredData();
  if (!dataFull || dataFull.length === 0) return;

  const idx = Math.round((x / canvas2.width) * (dataFull.length - 1));
  const clamped = Math.max(0, Math.min(dataFull.length - 1, idx));

  const prices = dataFull.map(d => d.price);
  const max = Math.max(...prices);
  const min = Math.min(...prices);
  const range = (max - min) || 1;

  const py = canvas2.height - ((prices[clamped] - min) / range) * canvas2.height;

  isHovering = true;
  hoverPos = {
    x: (clamped / (dataFull.length - 1)) * canvas2.width,
    y: py,
    index: clamped
  };

  drawChart();
});

canvas2.addEventListener('mouseout', () => {
  isHovering = false;
  hoverPos = null;
  drawChart();
});

/* ----------------------------
   Event log rendering (unchanged)
-----------------------------*/
function renderEventLog() {
  const el = document.getElementById('eventLog');
  el.innerHTML = '';

  for (let i = 0; i < Math.min(100, eventLog.length); i++) {
    const e = eventLog[i];
    const div = document.createElement('div');
    div.className = 'logItem';
    div.innerHTML = `<div style="font-size:12px;color:#9fd6ff">${e.t}</div><div>${e.msg}</div>`;
    el.appendChild(div);
  }
}

/* ----------------------------
   Details panel: live update (ensure reset when no selection)
-----------------------------*/
function updateDetails() {
  const details = document.getElementById('details');

  if (!selectedDetail) {
    details.innerHTML = `<div class="small muted">ì˜¤ë¥¸ìª½ ë³´ìœ ëª©ë¡ì—ì„œ ì¢…ëª©ì„ í´ë¦­í•˜ë©´, <br> ì´ê³³ì— ì‹¤ì‹œê°„ ì„¸ë¶€ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>`;
    return;
  }

  const type = selectedDetail.type;
  const idx = selectedDetail.index;

  if (type === 'Future') {
    if (idx < 0 || idx >= player.positions.futures.length) {
      selectedDetail = null;
      details.innerHTML = `<div class="small muted">ì„ íƒí•œ ì„ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
      return;
    }

    const f = player.positions.futures[idx];
    const tau = tauYearsFromExpiry(f.expiryDate);
    const curF = state.spot * Math.exp((R - Q) * tau);
    const pnlPer = (curF - f.entry) * (f.side === 'Long' ? 1 : -1);
    const pnl = pnlPer * f.qty;
    const pct = f.notional ? (pnl / f.notional) * f.lev * 100 : 0;

    details.innerHTML = `
      <h3>ì„ ë¬¼ ìƒì„¸ (ì‹¤ì‹œê°„)</h3>
      <div class="indRow"><div class="small muted">í¬ì§€ì…˜</div><div>${f.side} ${f.lev}x</div></div>
      <div class="indRow"><div class="small muted">ìˆ˜ëŸ‰</div><div>${f.qty}</div></div>
      <div class="indRow"><div class="small muted">ì§„ì…ê°€</div><div>${fmt2(f.entry)}</div></div>
      <div class="indRow"><div class="small muted">í˜„ì¬ê°€</div><div>${fmt2(curF)}</div></div>
      <div class="indRow"><div class="small muted">ì´ ê±°ë˜ê¸ˆì•¡</div><div>${fmt2(f.notional)}</div></div>
      <div class="indRow"><div class="small muted">ì¦ê±°ê¸ˆ</div><div>${fmt2(f.lockedMargin)}</div></div>
      <div class="indRow"><div class="small muted">ë¯¸ì‹¤í˜„ ì†ìµ</div>
        <div class="${pnl >= 0 ? 'profit' : 'loss'}">${fmt2(pnl)} (${fmt2(pct)}%)</div></div>
      <div class="indRow"><div class="small muted">ë§Œê¸°</div><div>${f.expiryDate}</div></div>
      <div style="margin-top:10px;"><button onclick="closeFuture(${idx})">ì¦‰ì‹œ ì²­ì‚°</button></div>
    `;
  } else if (type === 'Option') {
    if (idx < 0 || idx >= player.positions.options.length) {
      selectedDetail = null;
      details.innerHTML = `<div class="small muted">ì„ íƒí•œ ì˜µì…˜ì´ ì—†ìŠµë‹ˆë‹¤.</div>`;
      return;
    }

    const o = player.positions.options[idx];
    const cur = optionPremiumByExpiry(o.kind, state.spot, o.K, o.expiryDate);
    const paidPer = o.entryPremium;
    const totalPaid = paidPer * o.qty;
    const pnl = (o.side === 'Long') ? (cur - paidPer) * o.qty : (paidPer - cur) * o.qty;
    const pct = totalPaid ? (pnl / totalPaid) * 100 : 0;

    details.innerHTML = `
      <h3>ì˜µì…˜ ìƒì„¸ (ì‹¤ì‹œê°„)</h3>
      <div class="indRow"><div class="small muted">ì¢…ë¥˜</div><div>${o.kind} (${o.side})</div></div>
      <div class="indRow"><div class="small muted">í–‰ì‚¬ê°€</div><div>${fmt2(o.K)}</div></div>
      <div class="indRow"><div class="small muted">ìˆ˜ëŸ‰</div><div>${o.qty}</div></div>
      <div class="indRow"><div class="small muted">ì§€ë¶ˆ í”„ë¦¬ë¯¸ì—„</div><div>${fmt2(paidPer)}</div></div>
      <div class="indRow"><div class="small muted">ì´ ê±°ë˜ê¸ˆì•¡</div><div>${fmt2(totalPaid)}</div></div>
      <div class="indRow"><div class="small muted">í˜„ì¬ í”„ë¦¬ë¯¸ì—„</div><div>${fmt2(cur)}</div></div>
      <div class="indRow"><div class="small muted">ë¯¸ì‹¤í˜„ ì†ìµ</div>
        <div class="${pnl >= 0 ? 'profit' : 'loss'}">${fmt2(pnl)} (${fmt2(pct)}%)</div></div>
      <div class="indRow"><div class="small muted">ë§Œê¸°</div><div>${o.expiryDate}</div></div>
      <div style="margin-top:10px;"><button onclick="closeOption(${idx})">ì¦‰ì‹œ ì²­ì‚°</button></div>
    `;
  }
}

/* ----------------------------
   Render all UI elements (called each tick)
-----------------------------*/
function renderAll() {
  document.getElementById('datetime').innerText = nowStr(simDate);
  document.getElementById('marketStatus').innerText = isSpotOpenAt(simDate) ? 'ğŸŸ¢ ì¥ ì—´ë¦¼ (Market Opened)' : 'ğŸ”´ ì¥ ë‹«í˜ (Market Closed)';
  document.getElementById('spotPrice').innerText = fmt2(state.spot);

  document.getElementById('indVix').innerText = fmt2(econ.vix);
  document.getElementById('indPolicy').innerText = fmt2(econ.policyRate);
  document.getElementById('indBond').innerText = fmt2(econ.bondYield);
  document.getElementById('indGdp').innerText = fmt2(econ.gdpGrowth);
  document.getElementById('indUnemp').innerText = fmt2(econ.unemployment);

  updateOptPremiumDisplay();
  drawChart();

  document.getElementById('cash').innerText = fmt2(player.cash);
  const eq = computeEquity();
  document.getElementById('equity').innerText = fmt2(eq.total);

  const s = player.positions.spot;
  const spotEl = document.getElementById('spotHoldings');
  if (s.qty <= 0) {
    spotEl.innerHTML = `<div class="small muted">ì—†ìŒ</div>`;
  } else {
    const pnl = (state.spot - s.avg) * s.qty;
    const pct = s.avg > 0 ? (pnl / (s.avg * s.qty)) * 100 : 0;
    spotEl.innerHTML = `<div>ë³´ìœ  ${s.qty} | avg ${fmt2(s.avg)}</div><div class="${pnl >= 0 ? 'profit' : 'loss'}">${fmt2(pnl)} (${fmt2(pct)}%)</div>`;
  }

  // futures list
  const futEl = document.getElementById('futHoldings');
  if (player.positions.futures.length <= 0) {
    futEl.innerHTML = 'ì—†ìŒ';
  } else {
    futEl.innerHTML = '';
  }
  player.positions.futures.forEach((f, i) => {
    const tau = tauYearsFromExpiry(f.expiryDate);
    const curF = state.spot * Math.exp((R - Q) * tau);
    const pnlPer = (curF - f.entry) * (f.side === 'Long' ? 1 : -1);
    const pnl = pnlPer * f.qty;
    const pct = f.notional ? (pnl / f.notional) * 100 * f.lev : 0;

    const el = document.createElement('div');
    el.className = 'posItem';
    el.innerHTML = `
      <div><strong>${f.side}</strong> ${f.lev}x | ìˆ˜ëŸ‰ ${f.qty} | ì§„ì…ê°€ ${fmt2(f.entry)} | ë§Œê¸° ${f.expiryDate}</div>
      <div class="${pnl >= 0 ? 'profit' : 'loss'}">${fmt2(pnl)} (${fmt2(pct)}%)</div>
      <div class="small muted">ê±°ë˜ê¸ˆ ${fmt2(f.notional)} | ì¦ê±°ê¸ˆ ${fmt2(f.lockedMargin)}</div>
    `;
    el.onclick = () => { selectedDetail = { type: 'Future', index: i }; updateDetails(); };
    futEl.appendChild(el);
  });

  // options list
  const optEl = document.getElementById('optHoldings');
  if (player.positions.options.length <= 0) {
    optEl.innerHTML = 'ì—†ìŒ';
  } else {
    optEl.innerHTML = '';
  }
  player.positions.options.forEach((o, i) => {
    const cur = optionPremiumByExpiry(o.kind, state.spot, o.K, o.expiryDate);
    const paidPer = o.entryPremium;
    const pnl = (o.side === 'Long') ? (cur - paidPer) * o.qty : (paidPer - cur) * o.qty;
    const pct = paidPer ? (pnl / (paidPer * o.qty)) * 100 : 0;

    const el = document.createElement('div');
    el.className = 'posItem';
    el.innerHTML = `
      <div><strong>${o.side} ${o.kind}</strong> | ìˆ˜ëŸ‰ ${o.qty} | í–‰ì‚¬ê°€ ${fmt2(o.K)}</div>
      <div class="${pnl >= 0 ? 'profit' : 'loss'}">${fmt2(pnl)} (${fmt2(pct)}%)</div>
      <div class="small muted">ê±°ë˜ê¸ˆ ${fmt2(paidPer * o.qty)} | í˜„ì¬ í”„ë¦¬ë¯¸ì—„ ${fmt2(cur)}</div>
      <div class="small muted">ë§Œê¸° ${o.expiryDate}</div>
    `;
    el.onclick = () => { selectedDetail = { type: 'Option', index: i }; updateDetails(); };
    optEl.appendChild(el);
  });

  updateDetails();
  renderEventLog();
}

/* ----------------------------
   Opt premium display helper
-----------------------------*/
function updateOptPremiumDisplay() {
  const K = Number(document.getElementById('optK').value || state.spot);
  const months = Number(document.getElementById('optExp').value || 1);
  const expiryDate = addMonthsToFirst(simDate, months).toISOString().slice(0, 10);
  const kind = document.getElementById('optType').value;
  const prem = optionPremiumByExpiry(kind, state.spot, K, expiryDate);
  document.getElementById('optPremiumDisplay').innerText = `í”„ë¦¬ë¯¸ì—„: ${fmt2(prem)}`;
}

/* ----------------------------
   Debug tools wiring
-----------------------------*/
document.getElementById('toggleDebug').addEventListener('click', () => {
  const tools = document.getElementById('econDebugTools');
  if (tools.style.display === 'flex' || tools.style.display === 'block') tools.style.display = 'none';
  else tools.style.display = 'flex';
});

document.getElementById('dbgReset').addEventListener('click', () => {
  if (!confirm('ì‹œìŠ¤í…œ ì´ˆê¸°í™”: ëª¨ë“  í¬ì§€ì…˜ê³¼ ì§€í‘œë¥¼ ë¦¬ì…‹í•©ë‹ˆë‹¤. ê³„ì† ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
  resetSystem();
});
document.getElementById('dbgAddCash').addEventListener('click', () => {
  player.cash += 100000;
  pushEventLog('ğŸ§¾ Debug: í˜„ê¸ˆ +100k ì¶”ê°€');
  notify('í˜„ê¸ˆ +100k');
  renderAll();
});
document.getElementById('dbgWitch').addEventListener('click', () => {
  triggerWitchingEvent('debug');
  renderAll();
});
document.getElementById('dbgWhiteSwan').addEventListener('click', () => {
  triggerWhiteSwan('debug');
  renderAll();
});
document.getElementById('dbgBlackSwan').addEventListener('click', () => {
  triggerBlackSwan('debug');
  renderAll();
});
document.getElementById('dbgPolicyRateUP').addEventListener('click', () => {
  triggerPolicyRateUP('debug');
  renderAll();
});
document.getElementById('dbgPolicyRateDOWN').addEventListener('click', () => {
  triggerPolicyRateDOWN('debug');
  renderAll();
});
document.getElementById('dbgGDPGrowthUP').addEventListener('click', () => {
  triggerGDPGrowthUP('debug');
  renderAll();
});
document.getElementById('dbgGDPGrowthDOWN').addEventListener('click', () => {
  triggerGDPGrowthDOWN('debug');
  renderAll();
});
document.getElementById('dbgShowMU').addEventListener('click', () => {
  const mu = getCurrentMu()
  pushEventLog(`ğŸ«Ÿ í˜„ì¬ ì¶”ì„¸ ì¸ë±ìŠ¤: ${fmt2(mu)}`);
  renderAll();
});


/* ----------------------------
   Reset system (debug)
-----------------------------*/
function resetSystem() {
  simDate = new Date("2025-01-01T08:00:00");
  hoursPerTick = 1;
  state.spot = 10000.0;
  state.history = [{ t: new Date(simDate), price: state.spot }];
  econ = { vix: VIX_BASE, policyRate: RATE_BASE, bondYield: YIELD_BASE, gdpGrowth: GDP_BASE, unemployment: UEMP_BASE };
  player = { cash: 100000.0, positions: { spot: { qty: 0, avg: 0 }, futures: [], options: [] }, log: [] };
  eventLog = [];
  witchingActiveTicks = 0;
  blackSwanActiveTicks = 0;
  lastTickDay = null;
  lastTickMonth = null;
  selectedDetail = null;
  pushEventLog('ğŸ” ì‹œìŠ¤í…œ ì´ˆê¸°í™” (Debug)');
  renderAll();
}

/* ----------------------------
   UI event wiring for trading
-----------------------------*/
document.getElementById('buySpot').addEventListener('click', buySpot);
document.getElementById('sellSpot').addEventListener('click', sellSpot);
document.getElementById('openFut').addEventListener('click', openFuture);
document.getElementById('tradeOpt').addEventListener('click', tradeOption);
document.getElementById('optK').addEventListener('input', updateOptPremiumDisplay);
document.getElementById('optType').addEventListener('change', updateOptPremiumDisplay);
document.getElementById('optExp').addEventListener('change', updateOptPremiumDisplay);
document.getElementById('speedSelect').addEventListener('change', (e) => { hoursPerTick = Number(e.target.value) || 1; });

const periodButtons = document.querySelectorAll('.periodBtn');
periodButtons.forEach(b => {
  b.addEventListener('click', () => {
    periodButtons.forEach(x => x.classList.remove('active'));
    b.classList.add('active');
    chartPeriod = b.getAttribute('data-period');
    drawChart();
  });
});

/* ----------------------------
   Initialization & main loop
-----------------------------*/
state.history.push({ t: new Date(simDate), price: state.spot });
pushEventLog('ğŸš€ ì‹œë®¬ë ˆì´í„° ì‹œì‘ (spot 10,000)');
renderAll();
drawChart();
setInterval(() => { stepMarket(); }, 1000);


</script>
</body>
</html>
